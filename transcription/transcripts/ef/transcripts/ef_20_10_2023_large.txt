 Wir wollen uns heute weiter mit dem Thema Klassen und Objekte beschäftigen.
 Wenn die Lautstärke nicht genug ist, schreiben Sie bitte in den Chat und dann versuchen wir das so richtig zu machen.
 Wir wollen uns das Thema Klassen selber entwickeln zum ersten Mal ansehen.
 Das Thema wird uns einige Vorlesungen und sogar noch einige weitere Wochen beschäftigen.
 Wir werden heute versuchen, die Grundlagen der Klassen und des Class-Konstrukts zu diskutieren.
 Ich zeige Ihnen das Ergebnis der letzten Poll, wo Sie mit den Array-Parametern arbeiten mussten.
 Erfreulicherweise haben dieses Jahr 60 % der Studierenden, die daran teilnahmen, die Antwort richtig gemacht.
 Die anderen 40 % schauen sich das genauer an. Im Allgemeinen schätzen wir hier den Romen-Fonds.
 Ich bin kein Experte in allen anderen Fonds. Mein Japanisch ist leider auch nicht mehr so gut.
 Wenn Sie etwas schreiben, so dass ich es verstehen kann, hilft es mir.
 Warum brauchen wir jetzt Klassen? Was ist die Grundidee dahinter?
 Stellen Sie sich vor, Sie haben das Problem, das hatten wir schon mal angefangen,
 dass Sie für einen Verein die Körpergröße für die Mitglieder von verschiedenen Personen bearbeiten wollen.
 Nachdem Sie das gemacht haben, kommt die Zusatzaufgabe, dass Sie z.B. zusätzlich das Gewicht für jede Person einlesen sollten.
 Für die sechs Mitglieder dieser Gruppe würden Sie erst die Größe in Zentimetern und dann das Gewicht in Kilogramm angeben.
 Das ist eine Aufgabe, die Sie hätten. Das könnten Sie mit dem, was Sie bisher gelernt haben, ganz gut machen.
 Sie wollen die Daten analysieren oder etwas anderes machen, sehen, wer größer oder schwerer als der Durchschnitt ist usw.
 Würden Sie die Daten einlesen, würden wir das so machen, dass wir uns einen Scanner besorgen.
 Den nennen wir Input. Dann lesen wir die Anzahl der Input, die wir verarbeiten wollen.
 Für jede Person lesen wir einmal die Höhe und einmal das Gewicht, indem wir die Speicherwende in einem Array.
 Hier lesen wir die Höhe, die Speicherwende im Array. Dann lesen wir das Gewicht in Kilogramm und speichern es in einem anderen Array.
 Wir haben hier zwei Arrays, in denen wir die Größe und das Gewicht jeder Person abspeichern.
 Was für eine Dimension, also für die Größe, vor einer Woche oder anderthalb Wochen noch eine gute Idee war,
 jetzt mit zwei verschiedenen Dimensionen ist das eine sehr schlechte Lösung.
 Wenn Sie das so machen, dann haben Sie verschiedene Probleme, die Sie bearbeiten müssen.
 Zum Beispiel haben Sie das Problem, dass Sie sich jetzt sehr anstrengen müssten,
 wenn Sie die Personen, deren Daten Sie eingelesen haben, einmal nach der Größe sortieren und einmal nach dem Gewicht.
 Da ist es sehr schwer, nicht die Übersicht zu verlieren.
 Es ist sehr schwer, dafür zu sorgen, dass die Personen dann noch in der richtigen Reihenfolge in beiden Arrays auftreten.
 Das wäre sehr schwierig zu machen, wenn Sie zwei Arrays hätten, die Sie selber managen müssten.
 Das ist nur ein einfaches Beispiel mit zwei Dimensionen.
 Stellen Sie sich vor, zusätzlich wollen Sie zu den Personen die Adresse, das Semester und alles andere dazu speichern.
 Dann wird das sehr schwierig.
 Das hat ein ähnliches Problem, wenn Sie eine Datei haben, in der Sie Informationen über Orte in der Schweiz oder irgendwo speichern.
 Der erste Wert gibt dann wieder die Anzahl der Orte an, sowie die Anzahl der Personen.
 Dann kämen für die Orte, die Sie interessieren, die Koordinaten in diesen Schweizer Landeskoordinaten,
 die Sie vielleicht auch mal irgendwo kennengelernt haben.
 Irgendein Wert, der uns sagt, wo in der XY-Ebene wir diesen Ort finden würden.
 Jetzt sollten Sie ein Programm schreiben, dass es ein Tiefdruckgebiet gäbe.
 So etwas sollte es ja geben. Es hat ein Zentrum mit gewissen Koordinaten.
 Dann sollten Sie herausfinden, welche Orte innerhalb eines gewissen Radiuses um diesen Ort herum entfernt sind.
 Auch da hätten wir das Problem, dass Sie die X- und Y-Koordinaten, wenn Sie die in zwei unterschiedlichen Arrays speichern,
 schwer haben, den Bezug zu behalten und schwer herauszufinden, wer mit wem zusammengehört.
 Im ersten Fall hatten wir Daten, die eine Gruppe von Personen beschrieben,
 die uns Informationen über irgendwelche Personen geben.
 Wenn wir solche Daten speichern, dann sollten wir die vielleicht als Personenobjekte speichern.
 Also nicht als ein Objekt, das Informationen über die Personen hat.
 Im zweiten Fall hatten wir eine Menge von Punkten, also topografische Punkte oder andere Punkte.
 Es könnte auch ein dreidimensionaler Raum sein, wenn wir die Höheninformationen mit dazunehmen wollen.
 Solche Informationen sollten wir als Punktobjekte oder wenn wir verschiedene Punkte analysieren wollen,
 als Topopointobjekte, vielleicht brauchen wir auch Punkte in einem Raum, den wir modellieren.
 Dann hätten wir diese Informationen für einen Punkt zusammen in einem Objekt.
 Oder wir hätten die Informationen für eine Person in einem Objekt.
 Die Idee wäre, dass jedes Objekt diese Informationen für einen Punkt oder für eine Person
 oder was immer uns interessiert, zusammenbündeln würde.
 Also so ein Personenobjekt würde dann das Gewicht der Person, die Größe der Person,
 wenn das jetzt hier relevant ist, speichern.
 Und das hätte viele Vorteile für uns.
 Weil jetzt könnten wir uns überlegen, wie wir Personen vergleichen.
 Wir könnten sie einmal vergleichen nach der Größe.
 Da könnten wir sagen, jetzt suche die größte oder kleinste Person.
 Oder wir könnten sie vergleichen nach Gewicht.
 Wenn ich da ein Team zusammenstelle, gibt es da Regeln, wie schwer das sein darf oder nicht.
 Oder ich könnte, wenn ich das wollte, die Größe, die ich ursprünglich in Zentimetern erfahren bekommen habe,
 in eine andere Messeinheit, z.B. Zoll, also diese Inches, umrechnen.
 Oder von Zentimeter in Millimeter oder was auch immer.
 Das alles könnten wir machen.
 Und das wäre so vielleicht machbar, dass der Rest der Welt davon gar nicht so viel mitbekommen muss.
 Sondern nur die Teile des Systems, die damit arbeiten, die wären davon betroffen.
 Wenn ich jetzt diese Topografiepunkte hätte,
 da hätte ich dann eben für jeden Ort die XY-Koordinaten in diesen Schweizer Landeskoordinaten.
 Und dann könnte ich, wenn ich wollte, vielleicht zusätzlich die Höhe speichern.
 Oder ich könnte die Vegetation speichern.
 Oder ich könnte andere Informationen speichern, in welcher politischen Gemeinde sich der Ort befindet.
 Und natürlich könnten wir auch Berechnungen machen.
 Wir könnten den Abstand zu einem anderen Ort berechnen.
 Für dieses einfache Beispiel, dass ich mit dem Tiefdruckgebiet hatte, wäre das eine Möglichkeit, das zu machen.
 Oder einfach auch, um Reiseplanung zu machen.
 Und das Gute wäre, wenn wir das so machten, dann könnten wir vielleicht dafür sorgen,
 dass jeder dieser Punkte weiß, wie er auf einer Landkarte gezeichnet werden sollte.
 Also wenn ich dann irgendeine Operation sagen würde, hier, zeichne Punkt bitte, zeichnen.
 Und dann wüsste der, wie der in irgendeiner Landkarte gezeichnet werden müsste.
 Was für Schraffur oder was für Farbe oder was auch immer da genommen werden müsste.
 Also, wenn wir diesen Ansatz wählen, dass wir diese Informationen für jede Person oder jeden Punkt
 in einer zusammen abspeichern, dann können wir damit arbeiten.
 Und die Programme, die damit arbeiten, die könnten einfacher und kürzer werden.
 Warum? Die müssten jetzt nicht immer überlegen, das ist dieser Array und in diesem Array ist es diese Position.
 Und wenn ich jetzt das hier ändere, muss ich auch im anderen Array was machen.
 Ich kann einfach mit diesem Personenobjekt oder mit diesem Punktobjekt arbeiten.
 Natürlich, der Unterschied zwischen Personen und Punkten ist auch gegeben.
 Das heißt, wir werden dann sehen, dass wir vielleicht die eine Art von Objekten anders konstruieren müssen.
 Die Topografiepunkte werden sich wahrscheinlich nicht sehr ändern.
 Die anderen Punkte haben vielleicht andere, die Personenpunkte, da sind vielleicht Änderungen möglich.
 Aber das ist ein separates Problem, das eigentlich mehr die Anwender interessiert.
 Uns von der Informatik-Programmierseite interessiert mehr, was diese beiden Probleme zusammen haben.
 Nämlich, dass sie die Information für eine Person, einen Gegenstand, einen Ort, ein Konzept, irgendetwas zusammenspeichern.
 Und dafür gibt es eben in Java diesen Class-Konstrukt.
 Den haben wir schon einmal kennengelernt, um diesen namenlosen Service implementieren zu können.
 Wo wir dann eben diese Methode Main hatten und die Methode Main hat für uns die Arbeit erledigt.
 Und das war dann das Programm.
 Aber jetzt wollen wir weitergehen und wollen eben auch sehen, dass wir damit was anderes machen können.
 Wir können nämlich mit diesem Class-Konstrukt eine neue Art oder einen neuen Typ von Objekten beschreiben.
 Bisher haben wir nur Objekte genommen, die bereits von anderen vorbeschrieben worden waren.
 Wie eben diese Klassen Random und Scanner.
 Aber die mussten ja auch mal irgendwann erstellt werden.
 Am Anfang waren die ja auch was Neues.
 Und eben damals hatten wir dieses Random-Objekt, das eben Zufallszahlen generierte oder der Scanner, der Werte abliefert.
 Und diese Klassen waren eben uns gegeben.
 Und jetzt wollen wir eben da selber weitermachen und wollen eben halt uns selber Klassen überlegen, die sowas machen können.
 Und jetzt benutzen wir diesen Ausdruck Objekt, um ein Gebilde zu bezeichnen, das einen Zustand hat, also einen State.
 Und das auch Verhalten hat.
 Und dieser Class-Konstrukt wird uns erlauben, den Zustand mit dem Verhalten zu verbinden.
 Also das Verhalten auszudrücken, vielleicht in Abhängigkeit vom Zustand oder den Zustand auszudrücken, abhängig davon, was für verschiedene Operationen da gemacht worden waren.
 Und dann könnte eben dieses Objekt Services zur Verfügung stellen.
 Bei dem Scanner hatten wir gesehen, der hatte NextInt zur Verfügung gestellt.
 Der Zufallszahlengenerator hatte auch ein NextInt zur Verfügung gestellt.
 Das war eine gute Wahl.
 Okay, also wir wollen also hier Zustand und Verhalten miteinander verbinden.
 Und dann gibt es eben diese Objekte geben dann uns eben Services.
 Im Fall von Random und Scanner war bewusst der Name so gewählt, dass der Name der gleiche ist.
 Aber das muss nicht sein, das ist uns völlig frei überlassen, was wir da machen wollen.
 Und das ist so die Grundlage oder eine der Hauptideen des objektorientierten Programmierens.
 Das ist ein Programmmodell, das sich so ein Programm als eine Menge von Objekten organisiert.
 Also eine Menge von Objekten, die nicht so zusammengewürfelt sind, sondern eine Menge von Objekten, die miteinander was bewirken, also die aufeinander einwirken.
 Da kann das eine Objekt etwas über das andere Objekt tun und Informationen austauschen.
 Also ein Objekt ruft Methoden auf.
 Methoden, haben wir gesagt, sind Services, die ein anderes Objekt zur Verfügung stellt.
 Und dann liefern diese Methoden oder diese Operationen irgendwelche Werte zurück,
 die dann je nachdem, was wir machen, entweder in einem neuen Objekt gespeichert werden oder ein Objekt verändern.
 Und das ist das Modell, das wir hier im Laufe der Vorlesung verwenden.
 Das wird auch von vielen anderen Leuten verwendet und ist daher eine hoffentlich gute Investition in die Zukunft.
 Jetzt haben wir die Idee, dass wir Objekte erstellen wollen, die Zustand und Verhalten verbinden.
 Und dafür brauchen wir die Klasse.
 Die Klasse ist der Weg, wie wir beschreiben, wie diese Objekte aussehen.
 Sie können sich eine Klasse als eine Mustervorlage oder eine Schablone vorstellen.
 Die sagt, hier wollen wir ein Objekt haben und das soll diese möglichen Zustände haben.
 Oder das soll diese möglichen Operationen haben.
 Und wenn wir dann ein Objekt erstellen, dann wird ein Objekt gemäß der Vorlage erschaffen.
 Also ein Objekt wird erstellt, das dann die entsprechenden Zustände zulässt.
 Die Frage über den namenlosen Service ist, dass der Service, weil das in der Vorlesung behandelt wird,
 dass wir, wenn wir eine Klasse haben, wo wir die Main-Methode benutzen, um auszudrücken, was wir machen wollen,
 wir eigentlich dem Service keinen Namen geben.
 Es ist der Name des Programms und das Programm macht dann was.
 Und deswegen ist das namenlos.
 Aber wir wollen natürlich darauf hinarbeiten, dass wir irgendwann verschiedene Services anbieten können.
 Und wenn wir hier verschiedene Services anbieten können,
 dann müssen wir einen Weg finden, zwischen diesen Services unterscheiden zu können.
 Die Klassen beschreiben die Form oder die Funktionalität von Objekten.
 Das heißt, die sagen, was für Zustände die haben können, die sagen, was für Operationen möglich sind,
 die sagen auch vielleicht, was für Fehler auftreten können usw.
 Jetzt habe ich also die Klasse, die das beschreibt.
 Und dann sprechen wir von den einzelnen Objekten, entweder von Objektexemplaren oder einfach Exemplaren.
 Im Englischen heißt das Instances, aber das deutsche Wort Instanz heißt was ganz anderes.
 Deswegen sollten Sie das Wort eigentlich nicht verwenden, weil es eigentlich irreführend ist.
 Wenn wir von einzelnen Objekten sprechen, sprechen wir von Exemplaren oder Objektexemplaren,
 wenn wir es umgenau machen wollen.
 Das ist einfach vom Erstellen der Objekte.
 Und alle Objekte, die jetzt aufgrund einer Klasse gebildet wurden, die bilden einen Typ.
 Die haben bestimmte Eigenschaften zusammen, nämlich die Eigenschaft, dass sie die gleichen Zustände haben können
 und dass die gleichen Services angeboten werden oder dass die gleichen Operationen mit diesen Objekten gemacht werden können.
 Das ist der Ansatz, den wir hier verwenden.
 Man kann auch objektorientiertes Programmieren ohne Klassen machen.
 Es gibt ein paar Programmiersprachen, die machen das ohne Klassen.
 Sehr viele Programmiersprachen, die heute im Einsatz sind oder im verbreiteten Einsatz sind, sind klassenbasiert.
 Was Sie hier über Java hören, gilt ähnlich, ähnlich, nicht identisch zu C++ oder C#.
 Aber wir wollen uns eigentlich weniger die Details oder die Unterschiede zwischen den Programmiersprachen angucken.
 Das gibt es dann später mal.
 Wir wollen jetzt einfach nur sehen, wie wir damit unsere Programme etwas besser strukturieren können.
 Darum nehmen wir als erstes Beispiel eine ganz triviale Aufgabe.
 Wir wollen eine ganz einfache Klasse programmieren, die wir Point nennen,
 die dazu da sein soll, XY-Koordinaten in einer zweidimensionalen Ebene festzuhalten.
 Die XY-Koordinaten in der üblichen Ebene mit einem Nullpunkt werden wir als Basis nehmen.
 Jeder Punkt, der hier ist, kann durch ein Punktobjekt später repräsentiert werden.
 Das hat dann XY-Koordinaten.
 Diese Koordinaten nennen wir die Attribute dieses Punktes.
 Das sind alles Attribute.
 Dieses Attribut ist dann eben die XY-Koordinate, die wir da haben wollen.
 Dann wird es irgendwelche Operationen geben, die wir mit diesem Punkt machen können.
 Wir können zum Beispiel überlegen, ob man den geraden Abstand zum Nullpunkt berechnen kann.
 So etwas wäre eine Art von möglichem Verhalten, das wir für diese Objekte zur Verfügung stellen wollen.
 Jetzt brauche ich diese Punktobjekte.
 Die können dann von anderen Programmen verwendet werden.
 Unsere Punktobjekte selber geben uns nur die Punkte.
 Aber ein Programm, das damit arbeitet, die Fläche eines Rechtecks berechnet,
 würde mit den Punktobjekten arbeiten und müsste etwas mehr machen.
 Diese anderen Programme sind natürlich auch wieder durch Klassen beschrieben.
 Da schauen wir uns die nachher an.
 Aber jetzt schauen wir uns an, wie diese Punktobjekte genauer definiert werden müssen.
 All die Klassen, die mit diesen Punktobjekten arbeiten, nennen wir die Klienten der Punktklasse.
 Das werden wir nachher genauer schauen, was genau das heißt.
 Aber das ist ein Weg für uns, zusammenfassend zu sagen,
 alle Klassen oder alle Programme, die mit diesen Punktobjekten arbeiten, sind die Klienten.
 Dann werden wir vielleicht nächste Woche sehen, wie eine Klasse ihr eigener Klient sein kann.
 Das ist eine interessante Art von Klassen, in denen eine Klasse selber ihr eigener Klient sein kann.
 Das wird dann eine Vorbereitung auf etwas interessantere Datenstrukturen sein.
 Sie haben also diese Punktobjekte.
 Um mit denen zu arbeiten, braucht man natürlich wieder eine Variable.
 Wir können ja nicht auf das Objekt selber zugreifen.
 Wir müssen eine Variable haben.
 Das muss natürlich eine Referenzvariable sein,
 weil Referenzvariablen sich auf Objekte beziehen können.
 Das hatten wir auch bei den Eraser gesehen.
 Natürlich gilt für die Variable alles, was wir auch sonst gelernt haben,
 die muss deklariert sein, bevor wir das erste Mal mit ihr arbeiten können.
 Und natürlich sind diese Variablen an den Typ Point gebunden.
 Das heißt, sie können nur auf Point-Objekte verweisen.
 Sie können nicht auf beliebige Objekte verweisen.
 Genauso wie bei den Array-Referenzvariablen hatten Arrays, die mit Int-Elementen gefüllt sind,
 oder Arrays, die mit Strings gefüllt sind, oder Arrays, die mit Doubles gefüllt sind.
 Dafür gab es unterschiedliche Referenzvariablen.
 Und die eine konnte nicht für die andere verwendet werden.
 Es gibt einen Unterschied zwischen Methoden und Funktionen.
 Wo wir jetzt hier sind, können wir diese Worte noch austauschbar verwenden.
 Also Methode, Service, Funktion, Prozedur, das sind Begriffe, die wir eigentlich ziemlich gleich verwenden.
 Später werden Sie vielleicht sehen, dass man unterscheidet zwischen Methoden,
 die etwas verändern, und Funktionen, die nichts verändern.
 Aber für uns ist das jetzt noch ein und dasselbe.
 Wie würden wir so eine Referenzvariable deklarieren?
 Genauso wie wir es vorher gemacht haben.
 Wir nehmen den Typ und danach einen Namen, um diese Variable zu deklarieren.
 Also P1 wäre eine Referenzvariable, die sich auf Point-Objekte beziehen kann.
 Und P2 wäre eine Referenzvariable, die sich auch auf Point-Objekte beziehen kann.
 Die Deklaration macht den Namen bekannt, aber die Deklaration macht nur den Namen bekannt.
 Da gibt es noch kein Objekt.
 Genauso wie wir eine Array-Referenzvariable deklariert haben.
 Da gab es auch nicht sofort einen Array.
 Wenn wir mit einem Exemplar arbeiten wollen,
 dann müssen wir das Exemplar erst einmal erschaffen oder erstellen.
 Dafür brauchen wir wieder den New Operator.
 Hier habe ich den Point P1 und den lasse ich gleich auf einen neuen Point verweisen,
 den ich hier mittels des New Operators erstellt habe.
 Oder ich gehe hin und weise später dieser einmal deklarierten Variable eine neue Referenz zu.
 Das war genauso wie mit den Arrays.
 Wir hatten die Referenzvariable sofort initialisiert und ließen sie auf diesen Array mit zehn Elementen verweisen.
 Oder wir deklarierten die Variable und machten später eine Zuweisung,
 um sie auf einen konkreten Array verweisen zu lassen.
 Das ist mit diesen Point-Objekten nicht anders.
 Das geht genauso.
 Was wir als erstes festhalten sollten, Zustand plus Operationen ergibt einen Typ.
 Der Datentyp beschreibt, welche Operationen und welche Werte zulässig sind.
 Oft machen wir das so, dass wir sagen, diese Art von Werten kann da sein.
 Wir schränken das nicht weiter ein.
 Wenn wir so eine x-y-Koordinaten haben, dann werden wir einfach zulassen,
 dass jede mögliche x- und jede mögliche y-Koordinate zulässig ist.
 Wir machen also keine Aussage über die Größe der Fläche.
 Das könnte man auch machen, aber das machen wir im Allgemeinen nicht.
 Wir sagen einfach, zulässige Werte sind alle x- oder y-Koordinaten, die hier möglich sind.
 Wie bei den Arrays, wenn ich also eine Referenzvariable habe, kann ich mit der Referenzvariable arbeiten.
 Dann kann ich mit dieser Referenzvariable die Punkte entweder mir angucken oder verändern
 oder als Argument einer Methode übergeben.
 Da kann ich alles mitmachen, was ich will, genauso wie mit den Arrays.
 Ich kann mit denen arbeiten.
 Diese Punktobjekte, was für Zustände wollen wir jetzt da konkret haben?
 Ich sagte, so ein Punktobjekt kann jeden Punkt in der zweidimensionalen Ebene annehmen.
 Das heißt, wir müssen uns erst einmal überlegen, wie wir die nennen wollen.
 Da bieten sich natürlich x und y als Namen an.
 Da müssen wir festhalten, was diese Attribute sein sollen.
 Diese Attribute sollen die x-Koordinate oder die y-Koordinate sein.
 Wenn ich so etwas mit den Points haben will, dann muss das System dafür sorgen,
 dass dieses Objekt, wenn es gespeichert wird, Platz für diese Attribute hat und was sonst alles noch dazu kommt.
 Das ist Aufgabe der Klasse.
 In der Klasse werden wir sagen können, nicht heute, aber im Laufe der Woche,
 welche dieser Attribute für jeden zugänglich sind, welche dieser Attribute geändert werden können.
 Am Anfang machen wir es ganz einfach.
 Wir haben eine Referenzvariable und mit dieser Referenzvariable können wir uns auf ein konkretes Pointobjekt beziehen.
 Dann können wir damit arbeiten.
 Jetzt müssen wir natürlich irgendeinen Weg finden, um diese Pointobjekte auf konkrete Punkte verweisen zu lassen.
 Da muss es irgendeinen Weg geben, vielleicht mit einer Methode oder etwas anderem,
 die diesen Pointobjekten Werte gibt, damit wir damit arbeiten können.
 Dann können die Operationen damit weiterarbeiten.
 Wenn wir uns ein Pointobjekt erstellen, dann kommt das nicht ganz ohne irgendeinen Zustand heraus.
 Das muss einen legalen Zustand haben, weil das war eine unserer Aussagen über Objekte.
 Das heißt, irgendeine Werte werden da von dem New Operator bereits vorinstalliert.
 Das werden wir im Laufe der Zeit sehen, wie wir das genauer kontrollieren können.
 Für Punkte wäre zum Beispiel der Origin, der Nullpunkt, ein guter Wert, mit dem wir Punkte initialisieren können.
 Wir müssten überlegen, was der Punkt, der von dem New Operator erstellt wird, überhaupt für Werte haben soll.
 Dann wollen wir natürlich auch ein Verhalten haben, das beschreibt, was mit diesen Objekten gemacht werden kann.
 Da wird es wahrscheinlich irgendeine Operation geben, mit der wir die Koordinaten setzen können.
 Vielleicht können wir den Punkt auch verschieben, vielleicht wollen wir den Abstand zum Nullpunkt haben.
 Und wenn das ein Topografiepunkt ist, dann wollen wir irgendeinen Weg haben, den zu zeichnen oder sonst klarzumachen.
 Wenn Sie sehen, diese Topografiepunkte sind den Punkten ähnlich.
 Aber wenn wir jetzt einen Topografiepunkt erstellen wollten, dann sollte der für die Schweiz wahrscheinlich nicht 0,00 als Origin haben.
 In der Schweiz sind die Werte innerhalb eines gewissen Bereichs.
 Und wenn Sie sich noch erinnern, in der Schweiz ist der Ursprungspunkt ein ausgewählter Ort in einem anderen Kanton.
 Also, irgendwie müssen wir festhalten können, was die Werte sein sollen, wenn wir so ein Objekt erstellen.
 Und dann wollen wir natürlich auch Operationen haben, die könnten sehr ähnlich den Operationen sein, die wir für die anderen 2D-Punkte für unsere Ebene hatten.
 Diese Informationen werden wir also in die Klasse reinstecken.
 Und das, hatte ich gesagt, ist die Schablone oder das Muster.
 Das ist das Muster, das uns sagt, Punkte haben hier einen X- und Y-Zustand.
 Das beschreibt die X- und Y-Dimensionen dieses Punktes.
 Und dann gibt es verschiedene Schritte, die da gemacht werden könnten.
 Und wenn verschiedene Punkte erstellt wurden, dann können die unterschiedliche Werte für X und Y haben.
 Der eine Punkt hat hier X18 und Y42 und der andere hat X5 und Y-2.
 Das sind zwei unterschiedliche Punkte, die sich in ihren Zuständen unterscheiden, aber die Zustände sind immer noch ähnlich.
 Und die haben dann eben alle, weil es alles von derselben Schablone hergestellt wurde,
 haben das selbe Verhalten, dieselben Operationen, die da mitgemacht werden können.
 Also, die Klasse erlaubt es uns, so ein Gebilde zu konstruieren.
 Das ist die Vorlage und wenn wir das Objekt brauchen, wird ein Objekt gemäß dieser Vorlage erstellt.
 Also, müssen Sie sich das so vorstellen, wenn die Klasse das Objekt herstellen muss,
 dann wird das Objekt nach dieser Vorlage erschaffen.
 Das werden wir auch mal genauer angucken.
 Und dann wird das System dafür sorgen, dass die Operationen, die wir machen wollen, möglich sind.
 Und das wird dadurch der Fall sein, dass es für diese Operationen, die wir ausführen wollen, Methoden gibt.
 Wir hatten gesagt, dass alle Objekte, die wir erstellen haben, einen Zustand.
 Ist das noch da unten sichtbar? Ja, Zustand.
 Und diesen Zustand nennen wir die Attribute.
 Das sind die Attribute, die dieses Objekt beschreiben.
 Im Fall dieser einfachen Punkte wären das die xy-Koordinaten.
 Und im Fall eines Personenobjekts wären das vielleicht der Name und die Größe oder irgendwelche anderen Aspekte, die uns interessieren.
 Also, die Klasse ist dafür da, diese Gemeinsamkeiten zu beschreiben und das zu erstellen.
 Und damit kommen wir jetzt zu den ersten beiden Teilen, die diese Klasse beschreiben, die Attribute und die Methoden.
 Also, ich hatte gesagt, wir wollten für jedes Objekt zwei Aspekte festhalten, nämlich die x- und die y-Koordinate.
 Denn die bestimmen den Zustand des Exemplars.
 Das heißt, diese Daten müssen irgendwo gespeichert werden und das sind die Attribute, die Teil des Zustandes sind.
 Das ist vielleicht noch mehr vom System unterhalten, das wir nicht wissen.
 Aber das sind die Zustände, die das Programm als richtig oder wichtig herausgehoben hat.
 Und darum muss unser System in der Lage sein, diese zu speichern.
 Und es ist interessant oder wichtig zu sehen, dieses Attribut wird in der Klassenbeschreibung einmal für alle Objekte deklariert.
 Also wir sagen, jedes Objekt, das nach dieser Klasse deklariert wird, soll eine x- und eine y-Koordinate speichern.
 Was da einmal deklariert wurde.
 Aber dann, wenn wir einzelne Objekte oder Objektexemplare erstellen, dann werden die Attribute für jedes einzelne Objektexemplar separat gespeichert.
 Also die Operationen haben die alle gemeinsam, aber die werden trotzdem, die Information, die mit dem Objekt zusammengehört, wird für dieses Objekt gespeichert.
 Also das Attribut wird gespeichert und wir werden auch später sehen, dass zumindest im Prinzip die Operation auch an dieses Objekt gebunden ist.
 Das ist der Grund, warum wir dann in der Lage sind, so flexibel mit diesen Sachen zu arbeiten.
 Also unsere Klasse, wir würden das Keyword "Class" verwenden, um so eine Klasse zu deklarieren.
 Also diese Gruppe von Point-Objekten wird durch diese Klassendefinition beschrieben.
 Und wenn wir eben diese Attribute angeben, dann müssen wir den Attributen auch wieder einen Typ geben.
 Sonst weiß das System nicht, was für mögliche Zustände da erlaubt sind.
 Und wir sagen eben in diesem einfachen Beispiel, dass wir als Typ "Ints" nehmen.
 Also wir haben hier irgendeinen Wert, der sich durch eine Int darstellt.
 Kann man Klassen nachträglich anpassen? Machen wir sie erst mal. Danach werden wir sehen, was wir danach ändern können.
 So, dieser Code, den ich Ihnen hier gezeigt habe, der muss in einer ganz bestimmten Datei abgelegt sein.
 Die muss nämlich den Namen "Point.java" haben.
 Wenn sie den Namen nicht hat, dann beschwert sich das System.
 Aber das kennen Sie ja schon vom Beginn des Semesters.
 Das sind Regeln, an die wir uns halten müssen und die wir natürlich mit einem Aufwand umgehen könnten.
 Aber ich empfehle Ihnen, das gar nicht erst zu machen. Und darum, so eine Klasse würde jetzt hier in "Point.java" abgelegt sein.
 Wenn wir das gemacht haben, dann gibt es für unser Programm einen neuen Typ.
 Der Typ hat den Namen "Point" und jedes Point-Objekt oder jedes Point-Objekt-Exemplar enthält zwei Daten, zwei Attribute.
 Eine ganze Zahl, eine Int, die wir x nennen und eine andere ganze Zahl, die wir y nennen.
 Das ist unsere Point-Klasse, mit der wir arbeiten können.
 Wenn wir das so machen, haben wir diese Klasse definiert, aber wir haben noch kein Verhalten definiert.
 Darauf komme ich dann gleich.
 Aber erstmal wollen wir hier gucken, dass wir die Klasse definiert haben.
 Das ist manchmal eine sinnvolle Sache, weil so kann ich immer zwei Punkte zusammen bearbeiten.
 Die x und y sind die Attribute jedes Point-Objekts.
 Wenn wir von den Attributen reden, sind sie das, was das Objekt beschreibt.
 Um darauf zuzugreifen, brauchen wir wieder eine Referenzvariable.
 Die Referenzvariable legt den Typ des Objekts fest, auf das ich mit dieser Referenzvariable arbeiten kann.
 Wie ich vorhin schon zeigte, kann ich mit Point P1 eine Referenzvariable deklarieren,
 die sich auf Point-Objekte beziehen kann.
 Dann kann ich eine andere nehmen und die auf einen konkreten Point verweisen lassen.
 Diese Attribute sind also Variablen, die innerhalb eines Objekts als Teil des Objektzustandes gespeichert sind.
 Wichtig ist, dass Sie das innerhalb verinnerlichen.
 Die Variable, also das Attribut, ist im Objekt.
 Das ist vom Objekt umschlungen.
 Das Objekt ist wichtig.
 Ohne das Objekt kommen wir an diese Werte nicht heran.
 Die werden im Text zwischen den geschweiften Klammern deklariert.
 Die Syntax für diese Deklaration ist genauso, wie wir die Variablen in Methoden deklariert hatten.
 Wir geben einen Typ an, wir geben einen Namen an.
 Mir fragt jemand, ob diese Klassen innerhalb des Hauptprogramms Main sein müssen.
 Nein, ganz und gar nicht.
 Ihr Programm besteht aus einer Public Class, nennen wir die Main oder MAX.
 Dann kommt da was und dann haben Sie hier eine andere Public Class.
 Dann haben wir die Point.
 Ich hatte gesagt, die müssen in unterschiedlichen Dateien sein.
 Diese Klasse muss in der Datei MAX.java sein und diese muss in der Datei Point.java sein.
 Wenn Sie das nicht machen wollen, beschwert sich das System.
 Sie können das auch anders einstellen, aber warum wollen Sie sich das Leben schwierig machen?
 So haben Sie die verschiedenen Klassen.
 Wir werden später noch sehen, dass man das erweitern kann.
 Man kann das noch etwas komplizierter machen, aber das wollen wir jetzt am Anfang gar nicht machen.
 Wir haben einfach Klassen, die alle auf der obersten Ebene sind und mit denen wir arbeiten können.
 So habe ich das in meinem Programm.
 Die Attribute sind die Zustandsvariablen.
 Die können alles Mögliche sein.
 Die können String sein, Double sein, Arrays sein usw.
 Alles ist da ohne weiteres möglich.
 Wenn ich jetzt mit so einem Attribut arbeiten will,
 also wenn ich das lesen oder verändern will,
 das sind die beiden Wege, die wir kennen, um mit Variablen zu arbeiten,
 dann muss ich eine Referenzvariable nehmen.
 Ich nehme die Referenzvariable und dann habe ich diesen berühmten Punkt,
 den haben wir ja schon mal gesehen, und danach kommt das Attribut.
 So kann ich das Attribut lesen.
 Oder wenn ich das Attribut setzen will, mache ich das genauso,
 nur dass ich das auf die linke Seite schreibe.
 Dann habe ich hier eine Zuweisung.
 Dieser Value muss natürlich dem Typ entsprechen,
 den wir als Typ für diese Attribute definiert hatten.
 Wenn da ein Int verlangt ist,
 dann muss dieser Value, der berechnet wird, diesen Typ ergeben.
 Wenn wir mit diesen Punktkoordinaten arbeiten,
 haben wir hier eine Referenzvariable P1,
 die verweist auf einen Punkt, der hier konstruiert wird.
 Dann haben wir hier P2.
 Jetzt kann ich hier auf das X-Attribut zugreifen,
 und dann würde das gedruckt werden.
 Oder ich kann hier auf das Y-Attribut des Objekts zugreifen,
 dass ich mittels P2 erreiche und das auf irgendeinen Wert setze.
 Damit kann ich ganz normal ohne Umstände arbeiten.
 Wir werden später sehen, dass man das noch ein bisschen schwieriger machen kann,
 dass man das noch genauer kontrollieren kann, wer was lesen darf usw.
 Aber das wollen wir heute noch nicht machen.
 Wenn wir so eine Situation haben,
 hier haben wir eine Referenzvariable,
 wir haben hier den Punkt und wir haben hier ein Attribut,
 dann sagen wir, dass die Referenzvariable dereferenziert wurde.
 Wir nehmen die Referenzvariable und benutzen die, um ein Objekt zu finden.
 Dann gucken wir uns das Attribut dieses Objekts an oder setzen das Attribut.
 Das nennen wir dereferenzieren.
 Das D weist darauf hin, dass wir uns für das Objekt selber interessieren,
 nicht für die Attribute des Objekts interessieren,
 nicht für das Objekt als Ganzes.
 Dafür würden wir mit den Referenzvariablen arbeiten,
 sondern nein, für einen Aspekt dieses Objekts, für eines der Attribute.
 Dieser gleiche Weg, Referenzvariable, Punkt und Attribut,
 den können wir später auch benutzen, um Methoden aufzurufen.
 Auch da werden wir wieder eine Referenzvariable brauchen,
 wir werden den Punkt brauchen und natürlich brauchen wir dann kein Attribut,
 sondern den Namen einer Methode, gegebenenfalls mit Parametern.
 Also diese Dot-Notation, die wir auch früher schon mal gesehen haben,
 das ist der Weg, wie ich auf einzelne Attribute irgendeines Objekts zugreifen kann.
 Sie erinnern sich jetzt vielleicht, warum, jetzt wird es auch klar,
 als wir die Länge eines Arrays wollten, warum das eben ohne Klammern war.
 Weil dieses Length-Attribut ein Attribut des Arrays ist.
 Das ist ein Attribut, wenn ich hier irgendein Array habe,
 kann ich mittels dieser Notation auf die Länge zugreifen
 und mir die Länge anschauen.
 Das ist jetzt ein Attribut, das wir lesen können,
 das wir aber nicht ändern können.
 Es ist nicht möglich, durch die Änderung des Längen-Attributs
 die Länge des Arrays anzupassen.
 Das geht nicht, das unterstützt das System nicht.
 Deswegen war das eben ein Attribut, deswegen waren da auch keine Klammern.
 Was wir jetzt sagen würden, ist, dass die Referenzvariable "myArray",
 das ist die Referenzvariable, mit der wir hier arbeiten,
 die wurde dereferenziert, um auf das Attribut Length zuzugreifen.
 So haben wir das damals gemacht.
 Die Class beschreibt, wie die Objekte aussehen sollen.
 Und wenn jetzt ein Objekt erstellt wird, dann macht der New Operator das.
 Der New Operator weiß, wo die Information über die Klasse zu finden ist
 und erstellt dann ein konkretes Objekt, das ein Exemplar der Klasse ist.
 Oder manche Leute nennen es auch einen Repräsentanten der Klasse.
 Aber ein Zugriff auf die Attribute ist nur möglich,
 wenn es eben so ein Exemplar auch gibt.
 Genauso wie bei den Arrays.
 Wir mussten einen konkreten Array erstellt haben,
 auf dessen Elemente wir zugreifen konnten, wenn das Sinn machen sollte.
 Die Referenzvariable alleine gab uns noch keinen Array.
 Genauso ist es hier mit Referenzvariablen,
 die für eine Klasse oder für einen Typ, der durch die Klasse bestimmt wird,
 erstellt werden.
 Die Klasse ist nur die Vorlage.
 Die Klasse macht nichts selber.
 Und deswegen können wir auch in der Klasse keine Anweisungen haben,
 außer vielleicht Initialisierung.
 Und natürlich Methoden.
 Wir werden das noch sehen, dass wir Methoden definieren können,
 die uns sagen, wie wir mit der Klasse arbeiten wollen.
 Aber sonst gibt es in einer Klasse eigentlich keine Operationen.
 Das ist einfach nicht vorgesehen.
 Und daher gibt es so etwas für uns jetzt einfach auch nicht.
 Also, erste Zusammenfassung.
 New liefert uns einen Verweis auf ein Exemplar.
 Dieser Verweis kann in einer Referenzvariable gespeichert werden.
 Und das ist der Weg, wie wir zu Objektattributen kommen.
 Wir gehen hin und erstellen ein Objekt mit dem New Operator
 und greifen dann auf die einzelnen Attribute zu,
 indem wir die Referenzvariable in dieser Dot-Notation mit der Attribut verknüpfen.
 Und weil das Referenzvariablen sind, gelten natürlich die Reference Semantics.
 Die gleichen Regeln, die wir für Arrays hatten, gelten hier auch.
 Ich habe hier eine Referenzvariable p1, die sich auf diesen Punkt bezieht.
 Auf diesen Punkt habe ich die x- und y-Attribute auf 3 und 2 gesetzt.
 Jetzt habe ich hier eine zweite Referenzvariable, p2,
 die sich auch auf den selben Punkt bezieht, auf das selbe Objekt.
 Wenn ich mir jetzt das x-Attribut von p2 angucke, finde ich natürlich die 3.
 Und wenn ich mir das y-Attribut von p2 angucke, finde ich da natürlich die 2.
 Und wenn ich jetzt hingehe und das x-Attribut, das ich über p2 erreiche, in 4 ändere,
 dann sehe ich natürlich 4 und das y-Attribut ist unverändert.
 Aber genauso gilt, dass wenn ich mir das x-Attribut von p1 angucke, dass das auch 4 ist.
 Warum? Weil p1 und p2 sich auf das selbe Objekt beziehen.
 Wenn ich also diese Zuweisung gemacht habe, dann hat sich das geändert.
 Und danach eben auch p1, wenn ich mir das x-Attribut angucke, hat den Wert 4.
 Das ist wie seinerzeit das bei den Arrays war.
 Und wenn wir jetzt nicht mehr auf dieses, wenn wir jetzt nicht mehr wollen,
 dass dieses p1 oder p2 nicht mehr auf das Objekt verweist,
 dann machen wir das, was wir auch schon mal gesehen haben.
 Wir setzen diese Referenzvariable auf diesen besonderen Wert null.
 Null ist dieser besondere Wert, der ist gut für alle Klassen.
 Und wenn ich das einmal ausgeführt habe, dann ist p2 nicht mehr in der Lage,
 auf dieses Objektexemplar zuzugreifen und nur noch p1 greift darauf zu.
 Okay, haben wir jetzt Punkt für die Pause?
 Machen wir jetzt hier Pause und danach machen wir weiter.
 Wenn wir dafür sorgen wollen, dass diese Referenzvariable auf kein Objekt verweist,
 dann verwenden wir diesen besonderen Wert null.
 Das ist ein Wert, den jede Referenzvariable haben kann.
 Also jede Variable, die die Referent Semantics unterstützt.
 Sowohl die Referenzvariable für Arrays als auch die Referenzvariable für Typen,
 die wir selbst deklarieren.
 Nachdem ich das einmal auf null gesetzt habe, verweist das nichts mehr.
 Das geht natürlich auch mit Strings.
 Da kann ich, wenn ich will, dass dieser String auch auf keinen anderen String mehr verweist,
 auch diesen String zu null setzen.
 Wenn eine Referenzvariable den Wert null hat, dann sagen wir, es ist eine Null-Referenz.
 Und null kann eben nicht dereferenziert werden.
 Das ist der Wert einer Referenzvariable, die auf kein Objekt verweist.
 Wenn die auf kein Objekt verweist, dann sind manche Sachen nicht möglich.
 Also wenn es ein Objekt gibt, dann kann ich mir das x-Attribut angucken.
 Aber wenn es kein Objekt gibt, nachdem ich hier das zu null gesetzt habe,
 dann kann ich mir kein Attribut angucken.
 Da kann ich nicht sehen, was das y-Attribut ist, weil das eben nicht definiert ist.
 Genauso war das bei Arrays.
 Wenn es ein Array gibt, dann kann ich das Element mit Index 0 auf einen bestimmten Wert setzen.
 Oder ich kann die Länge abfragen.
 Aber wenn ich einmal diese Referenzvariable auf null gesetzt habe,
 dann kann ich nicht mehr die Länge abfragen.
 Und ich kann auch nicht irgendeines der Elemente auf irgendeinen Wert setzen,
 weil es eben keine Elemente gibt.
 Und dieses Null, daran erinnern Sie sich, wird auch benutzt, wenn ein neuer Array erstellt wird.
 Dann wurde damals jedes Element auf einen Wert gesetzt, der dieser Null entspricht.
 Für Zahlen waren das 0 oder 0.0.
 Aber für Strings hatten wir gesehen, war das dieser besondere Wert Null.
 Das gilt jetzt auch für Arrays, die auf Objekte verweisen können.
 Da wird das Element auf den Wert gesetzt, der 0 entspricht.
 Das heißt, wenn ein Array-Element auf irgendein Objekt verweisen kann,
 dann wird dieses Array-Element bei der Konstruktion auch auf Null gesetzt.
 Null ist der Wert, den wir vorfinden in unseren Arrays, bevor wir da konkrete Werte abspeichern.
 Wenn wir einen Array erstellen, der hier ein Array von Strings ist,
 dann gibt es einen Array zurück und jedes dieser Elemente hat den Wert Null.
 Wohingegen, als wir einen Int-Array erstellten, hatte jeder diesen Wert 0.
 Aber jetzt für Strings oder irgendwelche anderen Objektreferenzen wird das Element auf Null gesetzt.
 Das heißt, dass wir erst danach damit arbeiten können.
 Hier habe ich diesen Array "Words", der ein Array ist, der Platz für fünf String-Referenzen hat.
 Da habe ich hier diesen Array oder einen anderen Array, den ich für das Zeichnen brauche.
 Wenn ich den Array erstelle, sind die anfangs alle Null.
 Wenn ich jetzt so einen Array habe, kann ich das auch wieder mit einer direkten Initialisierung machen.
 Dann kann ich selektiv das Element mit dem Index 1 auf Null setzen.
 Dann ist das auf Null gesetzt und hat zurzeit keine Referenz auf irgendeinen String.
 Hat eine Referenzvariable den Wert Null, dann können wir sie nicht dereferenzieren, weil es auf kein Objekt verweist.
 Dereferenzieren heißt, wir gehen zum Objekt und sehen uns das Attribut an oder später rufen wir eine entsprechende Methode auf.
 Wenn eine Array-Referenzvariable den Wert Null hat, dann gab es keine Länge.
 Die Länge gibt es nur, wenn der Wert ungleich Null ist.
 Wenn der Wert Null ist, dann geht das nicht mehr.
 Nur wenn der Wert Null ist, geht es nicht.
 Der Wert muss ungleich Null sein.
 Das war der Grund, warum wir das Längenattribut nur abfragen können, wenn es einen wirklichen Array gibt.
 Wenn Sie jetzt doch versuchen sollten, die Null-Referenz zu dereferenzieren, dann beschwert sich das System.
 Dann beschwert sich das System und sagt, das geht nicht.
 Dann gibt es zur Ausführungszeit, also zur Laufzeit, einen Fehler.
 Das kann man erst zur Laufzeit feststellen, weil dann sieht man, dass da kein Objekt ist.
 Hier zum Beispiel haben wir P2 auf Null gesetzt.
 P2 ist eine Referenz, die auf denselben Punkt verweist wie P1.
 Jetzt setze ich danach auf Null.
 Wenn ich jetzt versuchen sollte, auf das x-Attribut oder y-Attribut zuzugreifen, dann gibt es einen Fehler.
 Man sagt, das System exception, das ist der Standardausdruck für Laufzeitfehler.
 Hier ist eine Exception und es gibt eine Null-Pointer-Exception.
 Das werden wir später noch einmal genauer angucken.
 Also Null ist eben ein Objekt, das eine Referenz sagt,
 dass diese Variable sich auf kein Objekt, kein Array, kein Objekt irgendeiner Klasse zurzeit bezieht.
 Das sollen wir nicht machen, dann gibt es entsprechenden Fehler.
 Nun ist es so, jemand fragte mich in der Pause, gibt es in Java Pointers?
 Die Antwort war damals, die sagte, nein, gibt es eigentlich nicht.
 So etwas machen wir nicht.
 Natürlich gibt es irgendwo Pointers tief im System.
 Und wenn Sie so etwas versuchen, wo Sie versuchen, eine Null-Referenz zu dereferenzieren,
 dann gibt es eine Null-Pointer-Exception, weil das System feststellt, dass hier etwas nicht in Ordnung ist.
 In der Implementation gibt es natürlich schon Pointer,
 aber für uns als Programmierer oder Programmiererin gibt es keine solcher Probleme.
 Das ist einfach die Regel, die wir hier haben.
 Da diese Null-Referenzen so ärgerlich sind, muss unser Programm normalerweise prüfen,
 ob eine Variable oder ein Array-Element, was auch immer, null ist.
 Oder wenn ich eine Methode habe, die eine Referenzvariable entgegennimmt,
 wenn ich nichts anderes weiß, muss die Methode eigentlich prüfen, ob die übergebene Variable null ist.
 Weil die könnte ja den Wert null haben und dann geht vieles nicht.
 Was erlaubt ist, was wir machen können, ist, wir können mittels dieses Gleichheitsoperators checken,
 ob ein Array-Element oder eine Variable null ist.
 Das kann ich checken und wenn das null ist, dann mache ich etwas nicht.
 Oder wenn es ungleich null ist, dann kann ich etwas machen.
 Wir werden später noch mehr über Exceptions lernen.
 Zurzeit wollen wir die einfach mal verhindern und wollen, wenn es geht, mit denen nichts zu tun haben.
 Aber wir können die eben nicht ganz ignorieren.
 Und wenn Sie eben versehentlich eine Null-Referenz dereferenzieren sollten, dann gibt es eben eine Exception.
 Ein stabiles Programm sorgt dafür, dass gecheckt wird, bevor eine Variable dereferenziert wird.
 Wir können natürlich checken, ob so eine Referenz null ist oder nicht.
 Sie haben hier einen Loop, der geht durch ein Array von Words durch.
 Und wenn dieses Element ungleich null ist, dann erst wollen wir hingehen und die Methode toUpperCase aufrufen.
 Wenn dieses Array-Element null wäre, dann würden wir das natürlich nicht machen wollen, weil das wäre dann gar nicht erlaubt.
 Also könnten wir einen expliziten Test haben, der sagt, wenn das Element ungleich null ist, dann bitte diesen Block ausführen.
 Aber das kann man noch ein bisschen kompakter schreiben.
 Und so sehen Sie es auch in vielen realistischen Programmen, dass wir eben halt oder könnten sogar auch hingehen und checken, ob das einen bestimmten Wert hat.
 Wir gucken nach, ob es nicht null ist.
 Wenn es nicht null ist, gucken wir nach, ob es einen bestimmten Wert hat.
 Und wenn das der Fall ist, dann gehen wir hin und setzen es in Großbuchstaben.
 Aber jetzt sehen Sie schon, jetzt haben wir hier ein IF, noch ein IF usw.
 Das ist eigentlich nicht das, was wir gerne wollen.
 Das sieht unübersichtlich aus.
 Und jetzt erinnern wir uns vielleicht daran, dass es bei der bedingten Auswertung doch so ist,
 dass die Auswertung aufhört, sobald wir wissen, was das Ergebnis ist.
 Also wenn ich einen logischen Und-Operator habe, sobald einer der Operanten false ist, hört die Auswertung auf.
 Weil wir wissen ja, das bleibt false.
 Und daher kann ich so eine Folge von Tests doch viel einfacher so machen.
 Ich checke erst, ob das Element, das ich im Array, mit dem ich arbeiten will, null ist oder ungleich null ist.
 Und wenn es ungleich null ist, dann gehe ich hin und checke danach, ob das Element eben diesen String hat,
 für den ich einen Schritt durchführen will oder etwas machen will.
 Also wenn das eben null sein sollte, wie hier, dann ist das hier false.
 Und dann wird dieser andere Teil gar nicht erst ausgeführt.
 Das heißt, ich habe so kompakt geschrieben, dass ich das nur ausführen will, wenn diese Bedingungen erfüllt sind.
 Die Referenz muss ungleich null sein und der String, auf den diese Referenz verweist, muss gleich dem String good-bye sein.
 Und dann erst will ich diese Operation machen.
 So können Sie das in vielen Programmen sehen und so können Sie auch selber,
 ohne eine Schachtelung von If-Statements machen zu müssen, selber kompakt checken,
 ob diese Referenz eine Null-Referenz ist oder nicht.
 Und eben sehr oft übergeben wir das Null als Parameter in eine Methode,
 wenn wir eben selber nicht ein weiteres Objekt geben wollen, mit dem Sie arbeiten sollen.
 Wenn ich eine Methode habe, die eine Referenzvariable erwartet, sei es eine Referenzvariable für ein Array,
 sei es eine Referenzvariable für irgendein Punktobjekt oder so etwas, kann ich immer Null übergeben.
 Und damit sage ich dann eben, in diesem Fall gibt es kein Array oder kein Pointobjekt usw.
 Und daher muss dann die Methode eventuell prüfen, ob der Parameter Null ist.
 Manchmal sagen unsere Aufgabenstellungen, Sie können sicher sein,
 dass die Referenzvariable oder der Parameter ungleich Null ist.
 Dann brauchen Sie nicht mehr checken.
 Aber wenn wir nichts sagen, ist es eine gute Idee, im Programm zu checken, ob die Referenzvariable Null ist.
 Und dann können Sie eben auch, was Sie auch oft sehen, Null zurückgeben.
 Wenn Sie Null zurückgeben, dann ist das vielleicht so eine Fehleranzeige.
 Normalerweise gibt die Methode einen Array zurück, aber jetzt gibt sie eben Null zurück,
 um zu sagen, da ist irgendwas schiefgelaufen.
 Also, noch mal eine Zusammenfassung.
 Die Referenzvariablen erlauben den Zugriff auf einen Array oder ein Objektexemplar.
 Und die Referenzvariable muss auf einen konkreten Array oder muss auf ein konkretes Objekt verweisen,
 um eben so einen Zugriff zu erlauben.
 Und erst, wenn wir eben Referenzvariable mit einem Objekt, also einem Array oder einem Exemplar,
 das wir durch eine Klasse konstruiert haben, verknüpft haben,
 dann erst können wir auf die Attribute zugreifen, auf die Elemente zugreifen usw.
 Sonst geht das alles nicht.
 Die Verknüpfung kann passieren, indem wir nachher so eine Zuweisung ausführen
 oder dass wir eine Zuweisung ausführen, wo wir auf der rechten Seite eine Referenzvariable haben,
 auf der linken Seite und die natürlich beide auf dieselbe Art von Objekten verweisen müssen.
 Das haben wir mit den Arrays auch gesehen.
 Wenn ich eine Referenzvariable habe, die sich auf einen Array von ganzen Zahlen beziehen kann,
 dann kann die sich auf einen beliebigen Array von ganzen Zahlen beziehen, egal welcher Länge.
 Und das ist die Einschränkung, die die Typdeklaration zur Folge hat.
 Und Referenzvariable verwenden immer Referent Semantics.
 Und das heißt, zwei oder mehr Referenzvariable können auf dasselbe Objekt verweisen.
 Ich habe hier dieses P1, das konstruiert so ein Punktobjekt.
 Und ich habe hier P2, das ich auf dieselbe Objekt verweisen lasse, das hier konstruiert wurde
 und in dem jetzt hier nachträglich die X- und Y-Attribute geändert wurden.
 Und wenn ich jetzt eben auf dieses Objekt zugreife, mittels P2, bekomme ich dieselben Attributwerte,
 die ich bekomme, wenn ich mittels P1 darauf zugreife.
 Und wenn eben die Referenzvariable P2 verwendet wird, um irgendein Attribut zu ändern,
 dann ist das auch durch die andere Referenzvariable sichtbar.
 Genauso wie wir es bei den Arrays waren.
 Genauso war kein bisschen anders.
 Und wenn wir eben Elemente eines Arrays haben, die Referenztypen sind,
 also ein Array von Strings oder ein Array von Points oder ein Array von irgendwelchen Panels oder was auch immer,
 so speichern natürlich diese Array-Elemente nicht das Objekt selber, sondern auch wieder nur einen Verweis auf das Objekt.
 Nur bei Basistypen, da wird der Wert direkt gespeichert.
 Bei allen Referenztypen speichert dann der Array eine Referenz.
 Und deswegen brauchen wir für die Initialisierung im Allgemeinen zwei Schritte.
 Erst werden wir den Array erstellen und initialisieren und dann gegebenenfalls die Referenzvariable auf diesen Array verweisen lassen.
 Also wenn ich eben den Array habe, am Anfang haben die Elemente alle den Wert 0 oder 0.0 oder auch Null,
 wenn es eine Referenz auf Objekte ist, dann kann ich da im zweiten Schritt hingehen und konkrete Objektreferenzen unterbringen.
 Oder beim String, das ist ein einfaches Beispiel eines Objekts, am Anfang besteht der Array aus vier Mal den Null-Referenzen
 und dann kann ich hingehen, in diesem Fall mache ich das so, dass ich in jedes dieser Elemente eine Referenz auf den String reinsetze,
 die ich hier konstruiere und ich konstruiere den String, der dadurch geformt wird, dass ich diesen String "Word" mit dem String konkateniere,
 der durch den Loopzähler angegeben wird.
 "Word 0", "Word 1", "Word 2" und so weiter.
 Da das eben Referenzvariable sind, was ich letzte Woche oder auch am Dienstag über die Array-Referenzen als Parameter gesagt habe,
 das gilt jetzt auch für diese Objekte, weil ich hatte damals ja gesagt, Array-Referenzen sind auch wieder Referenzen auf Objekte.
 Die können wir natürlich als Parameter übergeben und es gelten wieder die Referent-Semantics-Regeln.
 Das heißt, wenn ich ein Objekt übergebe, übergebe ich eine Referenz auf ein Objekt und ich übergebe das bei "Reference".
 Die Methode bekommt die Referenz und die kann dann eben mit diesem Objekt arbeiten, wenn das System das zulässt, das Objekt verändert.
 Wie beim Array-Parameter.
 Wenn ich ein Array-Parameter übergebe, kann die Methode die einzelnen Elemente des Arrays lesen und auch verändern.
 Das können Sie einmal ausnutzen, wenn Sie an verschiedenen Stellen in Ihrem Programm vom Keyboard lesen wollen.
 Es macht Sinn, so einen Scanner mit dem Input nur einmal zu konstruieren.
 Wenn Sie das mehrfach konstruieren, können andere Probleme auftreten.
 Dann haben Sie eine Referenzvariable-Konsole, die jetzt eine Referenz auf ein Scanner-Exemplar ist.
 Die können Sie jetzt als Parameter für diese Methode oder für eine andere Methode verwenden.
 Dann kann jede dieser Methoden von der Konsole lesen und dementsprechend weiterarbeiten.
 Diese Methode, die Sie irgendwo haben, das ist eine Methode hier, weil das ZX-System das Methoden in Ihrem Hauptprogramm.
 Die erwarten eine Referenz auf einen Scanner.
 Dass die Konsole jetzt reine, weil mir kein besserer Name eingefallen ist, heißt, der Name spielt keine Rolle.
 Diese Methode erwartet auch wieder eine Referenz auf einen Scanner.
 Und jede von denen kann dann entsprechend lesen und damit arbeiten.
 Also, Objekt als Parameter, wieder Referenzvariable.
 Dann ist es die Sache, das Objekt zu entscheiden, was für Operationen und gegebenenfalls Methoden möglich sind, was für Attribute existieren.
 Bei den Array-Elementen hatten wir gesehen, dass die verändert werden können.
 Aber wir hatten auch gesehen bei den Strings, dass Strings nicht verändert werden können.
 Wenn ich einen String übergebe, dann muss die Methode mit dem String arbeiten und kann sonst nichts anderes machen.
 Sie kann den String nicht verändern. Sie kann einen neuen String konstruieren, aber sie kann nicht verändern.
 Aber das war eine Entscheidung, die das Objekt gefällt hat oder die festgelegt wurde von den Leuten, die das Objekt erstellt haben.
 Die haben das so aufgesetzt, dass Änderungen nicht möglich sind.
 Und Strings können eben nicht verändert werden, weil man die eben besonders optimiert hat.
 Es gibt schon einen Weg, wie man auch das umgehen kann, aber das ist kein Thema für die Einführung in die Programmierung.
 Und Sie sollten auch nicht das versuchen, weil Programme, die das machen, sind sehr schnell unübersichtlich und vor allen Dingen, die funktionieren dann auch nicht immer überall.
 Das habe ich zum Thema Objekte und Attribute.
 Und jetzt wollte ich noch was zum Thema Klassen und ihre Klienten sagen.
 Nun ist es aber so, bei unseren Übungsaufgaben, die wir haben, wird es immer schwieriger, Aufgaben zu finden, die halbwegs interessant sind.
 Und deswegen haben wir uns gedacht, wir müssten Ihnen ein bisschen mehr über I/O erzählen, weil sonst das zu langweilig wird.
 Oder Sie verbringen zu viel Zeit damit, dass Sie Zahlen eingeben.
 Und deswegen haben wir gesagt, irgendwo bringen wir diese Kapitel 5 schubweise unter.
 Ein bisschen was mit I/O wollen wir ja machen.
 Und als erstes wollte ich Ihnen kurz zeigen, wie Sie statt von der Konsole einzulesen, mit Dateien arbeiten können.
 Das macht Ihr Leben vielleicht etwas leichter.
 Von daher mache ich das jetzt als Einschub.
 Die Slides finden Sie, falls Sie sie runtergeladen haben sollten, gegen Ende der anderen Slides, weil ich nicht genau wusste, wann ich den Einschub mache.
 Die finden Sie auch alle auf dem Netz.
 Und wenn Sie mal je sehen, dass Slides nicht auf dem Netz sind, schicken Sie mir Mail oder posten Sie es im Kurskanal.
 Dann ist irgendwas schiefgelaufen und wir versuchen das zu fixen.
 Jetzt wollen wir also nicht mehr nur von der Konsole lesen, sondern mit irgendwelchen Dateien arbeiten.
 Und da gibt es in Java eine Klasse File, die erlaubt Operationen mit Dateien, also mit Files.
 Und damit können wir solche Dateien lesen und schreiben.
 Und jetzt, wo wir wissen, was eine Klasse ist, können wir uns ungefähr vorstellen, was dahintersteckt.
 Und wir können dann auch verschiedene Operationen ausführen.
 Eine der Operationen ist zum Beispiel, dass wir herausfinden, wie groß ist die File.
 Und natürlich, das ist ein scharfes Messer, mit dem wir arbeiten.
 Wir können diese Dateien umbenennen, wir können die Dateien löschen.
 Sie können sich damit viel Freude begreiten.
 Wie machen wir das?
 Um das zu machen, müssen wir dem System sagen, dass wir mit Files arbeiten wollen.
 Das heißt, Sie müssen ein Import-Statement haben, das sagt, importiere diese File Services.
 Und wenn ich das einmal gemacht habe, dann wie bei dem Scanner, dann erstelle ich ein neues Exemplar dieses File Managers.
 Und dem gebe ich als String den Namen der Datei, die ich gerne öffnen will und mit der ich arbeiten will.
 Das sieht man natürlich nicht, aber das können wir ja fixen.
 Dann gebe ich hier als String den Namen der Datei, mit der ich arbeiten will.
 Und dann brauche ich natürlich wieder eine Referenzvariable.
 Die Referenzvariable ist vom Typ File, die bezieht sich auf File-Objekte.
 Und dann kann ich jetzt mit dieser Datei arbeiten.
 Und zum Beispiel könnte ich jetzt sagen, wenn dieser File existiert und die File eine Länge größer als 1000 Byte hat,
 dann möchte ich sie deleten.
 Aber dann ist sie weg.
 Und dann gibt es kein Backup, die ist einfach weg.
 Deswegen passen Sie auf, welches Beispiel Sie mit welchem anwenden und was Sie da machen.
 Jetzt, diese File, das ist nicht diese Referenzvariable, die erlaubt es mir, mit dieser File zu arbeiten.
 Das ist nicht die File selber, das ist eine Referenzvariable, die es mir erlaubt, mit dieser File zu arbeiten.
 Und was heißt arbeiten? Ich kann eine von verschiedenen Methoden ausführen oder Operationen ausführen.
 Ich kann also checken, ob die File überhaupt existiert.
 Ich kann checken, ob ich die File lesen kann.
 Je nach Betriebssystem gibt es da die Möglichkeit, das einzuschränken.
 Ich kann den Namen bekommen, ich kann die Länge bekommen, wie viele Elemente da sind.
 Ja, wir können die deleten, wenn wir wollen.
 Und wir können die auch umbenennen.
 Wichtig ist, diese Operationen, die machen Sie auf der Datei,
 aber die bestimmen Sie mit dem File-Objekt, das Sie hier erstellt haben.
 Dieser Konstrukt hier, der New Operator, gibt Ihnen ein File-Objekt, mit dem Sie jetzt arbeiten können.
 Und ein solches File-Objekt nennt man eine Handle.
 Also dieser Ausdruck "File", "New File" mit dem entsprechenden Namen,
 der erstellt nicht die Datei, der erstellt nur ein Objekt, mit dem Sie arbeiten können,
 das für die entsprechende Datei steht.
 Und so ein Objekt nennt man die Handle.
 Ich kenne kein gutes deutsches Wort dafür.
 Also es ist die Handle, mit der können Sie diese Datei entweder manipulieren oder inspizieren oder irgendwas machen.
 Damit können Sie Operationen mit der Datei machen.
 Dieser New Operator hier erstellt eben nur die Handle, er erstellt nicht die Datei selber.
 Und deswegen gibt es eben eine Methode, mit der Sie feststellen können, ob die Datei existiert.
 Deswegen gibt es diese Exist-Methode, weil ich kann ein File-Objekt, also so ein Objekt,
 kann ich erstellen für eine Datei, die es gar nicht gibt.
 Ich kann hier die Datei "fubar", den Namen "fubar" als Namen angeben, den gibt es wahrscheinlich in meinem Computer nicht.
 Das ist okay, weil jetzt habe ich eine Handle, mit der ich die Fubar-Datei, wenn sie existieren sollte, manipulieren kann.
 Das erstellt nicht diese Fubar-Datei.
 Wenn ich die erstellen will, dann muss ich andere Schritte machen, auf die komme ich dann nachher noch zu sprechen.
 Also wichtig ist, dass Sie wissen, dass Exist ist wichtig, damit Sie feststellen können,
 ob die Datei, deren Namen Sie da oben angegeben haben, bereits existiert.
 Jetzt haben wir so eine Datei und jetzt wollen wir aus der lesen.
 Und jetzt sehen Sie, das können Sie schon.
 Das haben Sie schon gelernt.
 Wir haben das schon mal input gemacht.
 Wir hatten doch den Scanner, da hatten wir einen neuen Scanner produziert, der für uns den Input machte, das Richtige.
 Und dann haben wir von dem Scanner gelesen.
 Und was, wenn ich jetzt von einer Datei lesen will, was mache ich dann?
 Da muss ich meinem Scanner sagen, der Scanner möge doch bitte nicht von der Konsole lesen, von System.in, sondern von einem anderen Ort.
 Und wie mache ich das?
 Ich gehe hin, ich gebe zum Beispiel den Dateinamen input.txt an, ich erstelle eine Handle, ein neues File Management Objekt
 und dann übergebe ich dieses Objekt an den Konstruktor, der den Scanner erstellen will.
 Und dann geht der hin und erstellt einen entsprechenden Scanner für uns, der jetzt aus dieser Datei die Daten liest.
 Und jemand fragte, File ist eben auch eine Klasse, der New Operator erstellt eine Referenz auf irgendein File Objekt.
 Das File Objekt, das sagt dann irgendwo, eines der Attribute wird dann sein, welchen Namen der Betreffende angegeben hat,
 ob man das lesen oder schreiben darf, wie lang das ist, vielleicht eine Million Bytes oder so was.
 Das alles wird in dieser Handle festgehalten und die gebe ich dem Scanner.
 Und der Scanner hat dann eben so einen Pointer und der weiß dann, von wo er die nächste Zahl oder was auch immer abliefern muss.
 Das sind jetzt hier zwei Schritte, die eben hier sehr oft zusammengefasst werden.
 Die werden so zusammengefasst, ich will einen neuen Scanner.
 Der soll hier für diese Datei erstellt werden, die ich hier durch diese File Handle, die ich jetzt hier on the fly konstruiere, erstellen möchte.
 Sowas finden Sie häufig in Programmen und dann können Sie natürlich da alle Fallnamen Ihrer Wahl einsetzen.
 Wo finden Sie jetzt mehr Dokumentation über den Scanner?
 Da können Sie eben Dokumentation finden, sei es über irgendeinen Search Service oder irgendwas.
 Der Java 11 Scanner ist der gleiche wie der Java 17 Scanner.
 Da finden Sie dann Informationen über die Klasse Scanner und da finden Sie dann eben halt Informationen und so weiter, wie man damit arbeitet und so weiter.
 Da gibt es einiges mehr, da gibt es noch viel mehr Text, den ich Ihnen gar nicht zeigen will.
 Jetzt gibt es halt verschiedene Möglichkeiten, so einen Scanner zu konstruieren.
 Da gibt es eben unterschiedliche Inputquellen und diese Inputquellen haben wir ja gesehen, die wurden dem Scanner als Parameter übergeben.
 Wir hatten einmal System.in dem Scanner gesagt, wir wollen von System.in lesen und dann war der Scanner aufgesetzt worden, um von der Konsole zu lesen
 oder wir sagen, der Scanner soll von der Datei lesen, die durch dieses File-Objekt beschrieben ist.
 Wenn wir das jetzt machen, da sehen wir halt hier, da sind verschiedene Optionen.
 Wir können eben einen Scanner haben, der uns aus einer File liest, wir können die Charactersets ändern, wir können unser System mit einem Western Key Set,
 also Buchstabenset schreiben und dann Buchstaben in einem anderen Alphabet lesen.
 Das kann man alle viele Sachen machen, ist eigentlich nicht unser Problem.
 Wir nehmen den einfachsten Fall, dass wir einfach aus einer Datei lesen wollen.
 So, dann gucken wir uns an, hier gibt es also die Regel, weitere Informationen über diesen Scanner.
 Da sagen wir, er konstruiert einen Scanner, der Werte liefern wird und so weiter.
 Wenn wir weiter gucken, da sehen wir hier unten eine Warnung.
 File not found exceptions, die wird geworfen, wenn die Quelle nicht gefunden wurde.
 Was bedeutet das?
 Jetzt können wir sagen, wir wollen mal gucken, was das ist.
 Wir könnten ja ein Programm schreiben, das so etwas macht.
 Wir haben hier ein Programm, unser Main-Programm, unser anonymes Service-Programm, haben wir FileIO genannt.
 Hier haben wir die Main-Methode und in dieser Main-Methode machen wir, was ich eben vorgestellt habe.
 Wir versuchen eben da einen Scanner für diese Datei zu erstellen.
 Wenn wir das machen, dann beschwert sich das System.
 Der beschwert sich konkret der Compiler und sagt, unhandled exception type, file not found exception.
 Da gibt erfreulicherweise Eclipse bereits zwei Hilfsmöglichkeiten.
 Die erste da, add source declaration, die werde ich jetzt noch gerade erklären.
 Die zweite Option, die muss später kommen.
 Da muss man noch ein paar mehr Sachen erklären, um das später anders zu machen.
 Was geht hier vor oder was passiert?
 Also, Exceptions, hatte ich schon mal gesagt, ist ein Fehler, der während der Laufzeit auftritt.
 Das ist eine Ausnahme, ist die Folge eines Fehlers, der erst zur Laufzeit festgestellt werden kann.
 Zum Beispiel, das hatten wir auch schon mal gesehen, wenn wir versuchen, eine ganze Zahl, also eine Int, durch null zu dividieren.
 Das haut nicht hin, da gibt es eben einen Fehler.
 Oder wenn wir versuchen, auf ein Array-Element zuzugreifen, das nicht existiert.
 Das haut auch nicht hin, da gibt es auch einen Fehler.
 Oder wenn wir versuchen sollten, eine Null-Referenz zu dereferenzieren, dann gibt es auch einen Fehler.
 In all diesen Situationen, oder Lesen des falschen Typs, wenn wir in der Datei oder im Input eine Int erwarten,
 also eine ganze Zahl erwarten und es kommt irgendein Text, dann gibt es auch eine Exception.
 In all diesen Situationen beschwert sich das System und genauso in dem Fall, wenn wir versuchen, aus einer Datei zu lesen, die nicht existiert.
 Und wenn wir jetzt versuchen sollten, aus so einer Datei zu lesen, dann stellt das System fest zur Laufzeit, dass die Datei gar nicht existiert.
 Und dann wird eine Exception generiert, das genau sehen wir später, das ist auch wieder ein Objekt.
 Ein Objekt, das eben die Exception modelliert.
 Und diese Exception wird weitergereicht, bis irgendein Teil des Programms diese Exception bearbeiten kann.
 Vielleicht kann das das Programm selber oder wenn das Programm das nicht kann, dann gibt es vielleicht jemand anders in der Java-Umgebung, der das behandeln kann.
 Und das ist das, was wir Werfen nennen.
 Das Programm generiert die Exception und reicht sie weiter.
 Das nennen wir Werfen. Die Exception wird geworfen.
 Und jetzt gucken wir mal, welcher Teil des Programms in der Lage ist, diese Exception zu behandeln, also in der Lage, die aufzufangen.
 Hier haben wir ein Beispiel, so wie es bisher ist, unser Main-Programm.
 Da haben wir eine Methode foo.
 Die Methode foo ruft eine Methode bar auf.
 Und jetzt geht unser Programm hin und führt das Main aus, ruft foo auf, dann wird erst main aufgerufen, dann foo, dann wird bar aufgerufen.
 Und dann wird das Programm ausgeführt und dann geht es wieder zurück und dann geht es zurück und dann geht es zurück und dann sind wir fertig.
 So ist der normale Fluss unseres Methodenaufrufs.
 Wenn wir jetzt aber hingehen und diese Methode ändern, und zwar dahingehend ändern, dass wir versuchen, durch null zu dividieren,
 dann passiert am Anfang alles noch genauso.
 Und wir kommen jetzt zu dem Punkt, dass die Division durch null gemacht wird.
 Da wird eine Exception festgestellt, da ist ein Fehler aufgetreten.
 Und jetzt im nächsten Moment, da eben niemand von diesen anderen Methoden in der Lage ist, diesen Fehler zu beheben,
 springen wir sofort zu einem Punkt außerhalb dieser drei Methoden hin.
 Das heißt, da wird dann hoffentlich jemand sein, der diese Exception auffängt.
 Und das System ist hoffentlich so aufgesetzt, dass da die Exception gefangen werden kann.
 Und Java bemüht sich eben zu verhindern, dass da irgendwelche Kontrolltransfers stattfinden, die man nicht vorher gesehen hat.
 Und daher ist das System so aufgesetzt, dass wir für jede Exception irgendwo einen Händler haben müssen,
 also ein Programmsegment haben müssen, das diese Exception bearbeitet.
 Jetzt gibt es bei den Exceptions zwei große Gruppen.
 Da gibt es einmal Exceptions, die müssen vom Programm aufgefangen werden.
 Es gibt andere Exceptions, wie zum Beispiel, dass die Batterie aufgehört hat oder dass der Prozessor nicht mehr funktioniert.
 Da kann das Programm nichts machen und da erwarten wir auch nichts.
 Aber viele Exceptions, so wie Null-Referenz oder so, da erwarten wir, dass das Programm die eigentlich auffängt.
 Jetzt gibt es Exceptions, die können überall auftreten, eben wie die Division durch null oder das Dereferenzieren von null
 oder solche Sachen.
 Und auf diese Exceptions ist das Java-System vorbereitet.
 Das heißt, das Java-System hat dafür gesorgt, dass wenn Sie durch null dividieren,
 irgendwer geht hin und wird das dann entsprechend auffangen und damit bearbeiten.
 Dann gibt es andere Exceptions, und das sind die, die etwas komplizierter sind.
 Da weiß das System nicht, dass so eine Exception auftreten kann.
 Das heißt, das System braucht Hilfe, um zu wissen, wie eine solche Exception behandelt wird.
 Es ist nicht so, dass alle Programme aus einer Datei lesen.
 Daher ist die Exception, dass die Datei nicht da ist, nicht eine von den Exceptions, auf die das System bereits vorbereitet ist.
 Daher müssen wir dem System helfen, diese Exception zu managen.
 Diese Exceptions, für die das System mehr Informationen braucht, nennen wir Checked Exceptions, überprüfte Ausnahmen.
 Das sind Ausnahmen, die das System noch überprüfen wird, bevor es zulässt, dass wir mit solchen Ausnahmen arbeiten.
 Und wer prüft hier?
 Natürlich der Compiler.
 Wenn der Compiler prüft, ob eine Exception entweder lokal aufgefangen wird, dann ist der Compiler zufrieden.
 Oder wenn er die aufgerufene Methode angibt, dass eine Exception auftreten kann, dann ist der Compiler auch zufrieden.
 Wenn eine Methode sagt, ich bin in der Lage, ich reiche diese Exception weiter, und irgendjemand anderes ist bereit, die zu bearbeiten,
 dann weiß der Compiler, dass es irgendwo einen Teil gibt, der das bearbeiten wird.
 Und dann checkt der Compiler, ob solche Exceptions richtig aufgesetzt wurden.
 Und wenn das nicht der Fall ist, dann beschwert sich der Compiler und sagt, dieses Programm können wir nicht übersetzen.
 Das haben Sie vorhin gesehen.
 Dann gibt es eben diese Error Message, unhandled exception type, file not found exception, wissen wir nicht, was wir damit machen können,
 und da müssen wir irgendwas unternehmen.
 Das heißt, wir müssen festlegen, wie unser Programm mit I/O-Problemen umgeht.
 Sonst weiß das System das ja nicht.
 Jetzt gibt es zwei Möglichkeiten.
 Die eine ist, selber lokal zu machen oder einfach die Arbeit zu delegieren an jemand anderes.
 Und das ist dieser Vorschlag, eine Add-Source-Deklaration, eine Source-Deklaration dazu zu fügen.
 Das ist eine Ankündigung, die ich bei der Deklaration einer Methode mache,
 wo ich sage, diese Methode könnte diese Exception generieren oder die könnte von woanders herkommen.
 Und diese Methode wird diese Exception nicht selber auffangen.
 Das heißt, wer immer diese Methode aufruft, muss dafür sorgen, dass die Exceptions bearbeitet werden.
 Also wer die Methode aufruft, muss diese Exception entweder fangen oder wiederum ankündigen.
 Bis es eben ganz nach oben geht, und ganz nach oben, also im IAVA-System, ist man natürlich vorbereitet,
 alle Arten von Exceptions, die behandelt werden können, in irgendeiner Form aufzufangen.
 Das heißt also, in unserer Methode, wenn wir eine Methode, eine Static-Methode haben,
 dann würden wir hinterher schreiben, Source-Type, oder genauso, wenn wir später eine andere Methode schrieben,
 die wir auch ankündigen müssen, da würden wir schreiben, dass diese Methode eine solche Exception generieren kann.
 Und dann danach erst kommen die geschweiften Klammern, in denen der Body der Methode ist.
 Und natürlich muss ein Type ein Exception-Typ sein, da kann nicht irgendein beliebiger Typ sein,
 sondern eben die Art der Exception, die geworfen werden kann.
 Und das gilt für Methoden, gilt für die Art, wie wir Objekte konstruieren usw.
 Da muss das eben, wenn das angekündigt wird, müssen wir damit arbeiten.
 Also wenn ich sage, hier gibt es einen Weg, ein Objekt zu deklarieren,
 dann kann ich sagen, aber diese Deklaration wirft eventuell eine solche Exception.
 Und das ist das, was wir vorher gesehen haben.
 Als wir gesehen haben, dass dieser Weg, den Scanner zu konstruieren,
 indem wir eine Datei als Datenquelle übergeben,
 da ist es eben möglich, dass der Versuch, einen solchen Scanner zu konstruieren,
 dass der eben eine solche Exception generieren wird.
 Und die wird auftreten, wenn diese Datei, mit der wir arbeiten wollen, nicht existiert.
 Da steht dieses Roast.
 Das heißt, wer immer den New Operator mit dieser Form von Konstruktionsanweisung verbinden will,
 der muss sich eben um diese Exceptions kümmern.
 Und das können wir einfachst machen, indem wir einfach hier dieses dazufügen.
 Wir sagen unsere Methode Main, die wirft auch möglicherweise eine File Not Found Exception.
 Wir hoffen ja nicht, dass das passiert, weil wir werden ja hoffentlich immer nur Dateinamen geben,
 die auch existieren.
 Aber sollte es mal einen Dateinamen geben, der nicht existiert, dann wird das passieren
 und das System ist darauf vorbereitet.
 Dann ist der Compiler zufrieden, das System ist zufrieden, die Methode funktioniert,
 alles wird richtig aufgesetzt und so weiter.
 Nicht alle Konstruktoren hatten das Problem.
 Und deswegen, wenn wir einen Inputstream hatten wie den System.in, da kann das nicht passieren.
 Und deswegen konnten wir eben auch einen Scanner System.in erstellen.
 So, und jetzt noch ganz einfach drei Worte zum Thema Output.
 Jetzt haben wir so eine Datei, jetzt wie können wir da schreiben?
 Da gibt es auch wieder einen guten Service, den wir auch benutzen können,
 nämlich die Printstream-Klasse.
 Das ist ein anderer Service, der es uns erlaubt, Daten elegant und einfach in eine Datei auszugeben.
 Und all die Operationen, die wir von System.out kennen, die funktionieren auch mit Printstream.
 Also Print, Printline.
 Ist einfach so, wie wir es vorher gesehen haben.
 Müssen wir natürlich importieren, aber ich gehe hin, ich habe wieder meinen File Handle
 für die File, die ich haben will.
 Und dann gehe ich hin und möchte gerne einen neuen Printstream haben.
 Einen Printstream, der mit dieser File arbeitet.
 Oder eben kompakt hier, alles auf einer Stele.
 Einen Printstream, der mit dieser Datei arbeitet.
 So, und wenn ich das habe, dann ja.
 Wie hatten wir vorher gedruckt?
 Wir hatten hier unseren Loop, der zum Beispiel irgendwas zehnmal das druckt.
 Das ging durch System.out.
 Und jetzt gehen wir hin und definieren uns eben einen entsprechenden Printstream,
 dem wir vielleicht den Namen Fileoutput geben.
 Und jetzt brauchen wir hingehen und ersetzen das System.out durch den Fileoutput-Stream,
 den wir hier oben konstruiert haben.
 Und damit können wir, genauso wie wir zur Konsole drucken können,
 können wir jetzt eine Datei ausschreiben.
 Und das Schöne ist, wenn die Datei nicht existiert, dann wird sie erstellt.
 So können wir also unsere eigenen Daten da schreiben.
 Natürlich, nichts ist umsonst.
 Was passiert nämlich, wenn sie existiert?
 Naja, wenn sie existiert, die Datei, dann wird sie überschrieben.
 Weil wir haben ja jetzt gesagt, wir wollen hier auf diese Datei, wollen wir jetzt schreiben.
 Und darum eben müssen wir aufpassen.
 Wenn wir eben sehen wollen, was da gemacht ist, müssen wir in Eclipse Refresh machen.
 Dann wird die Datei, refresht das System sich und dann können wir auf die Datei gucken.
 Und dann sollte die Datei, wenn die jetzt Output.txt hieß, die sollte erscheinen.
 Aber im Projektfolder, nicht im Java-Sourcefolder.
 Da würden Sie die dann finden und würden die dann entsprechend sehen.
 Da würden Sie dann das 10 mal sehen.
 Also wie gesagt, Printstream ist sehr komfortabel.
 Beliebter Fehler ist, eine Datei zum Schreiben öffnen, die Methode mehrfach ausführen.
 Dann wird die Datei mehrfach geöffnet.
 Aber der alte Inhalt geht verloren.
 Nur der letzte Output kann in der Datei gefunden worden.
 Daher also bitte aufpassen, wenn Sie so etwas in einem Loop machen,
 dass Sie sich bitte schön selbst nicht in die Füße schießen.
 Das ist alles zum Thema Printstream und damit wünsche ich Ihnen ein schönes Wochenende
 und bis nächste Woche Freitag.
 [Beifall CDU und BÜNDNIS 90/DIE GRÜNEN]
